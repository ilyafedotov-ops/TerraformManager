// Generated by TerraformManager â€” AWS ALB + WAF baseline


provider "aws" {
  region = "us-east-1"
}

locals {
  common_tags = {
    ManagedBy   = "TerraformManager"
    Environment = "prod"
    Owner       = "platform"
    CostCenter  = "ENG"
  }
}

variable "alb_certificate_arn" {
  description = "ACM certificate ARN for HTTPS listener"
  type        = string
}

variable "target_group_arn" {
  description = "Existing target group ARN or create separately"
  type        = string
}

resource "aws_lb" "alb" {
  name               = "app-alb"
  load_balancer_type = "application"
  security_groups    = ["sg-abc123"]
  subnets            = ["subnet-111","subnet-222"]
  idle_timeout       = 60
  enable_deletion_protection = true
  enable_http2       = true
  internal           = false
  drop_invalid_header_fields = true
  
  access_logs {
    enabled = true
    
    bucket  = aws_s3_bucket.app_alb_logs.bucket
    
    prefix  = "app-alb/alb"
  }
  

  tags = local.common_tags
}


resource "aws_s3_bucket" "app_alb_logs" {
  bucket = "app-alb-logs"
  acl    = "private"

  tags = local.common_tags
}

resource "aws_s3_bucket_public_access_block" "app_alb_logs" {
  bucket = aws_s3_bucket.app_alb_logs.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

resource "aws_s3_bucket_server_side_encryption_configuration" "app_alb_logs" {
  bucket = aws_s3_bucket.app_alb_logs.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

resource "aws_s3_bucket_policy" "app_alb_logs_log_delivery" {
  bucket = aws_s3_bucket.app_alb_logs.id

  policy = <<POLICY
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AWSALBLogDelivery",
      "Effect": "Allow",
      "Principal": {
        "Service": "logdelivery.elb.amazonaws.com"
      },
      "Action": "s3:PutObject",
      "Resource": "${aws_s3_bucket.app_alb_logs.arn}/app-alb/alb/*",
      "Condition": {
        "StringEquals": {
          "s3:x-amz-acl": "bucket-owner-full-control"
        }
      }
    },
    {
      "Sid": "AWSALBLogDeliveryGetAcl",
      "Effect": "Allow",
      "Principal": {
        "Service": "logdelivery.elb.amazonaws.com"
      },
      "Action": [
        "s3:GetBucketAcl",
        "s3:ListBucket"
      ],
      "Resource": "${aws_s3_bucket.app_alb_logs.arn}"
    }
  ]
}
POLICY
}


resource "aws_lb_listener" "alb_https" {
  load_balancer_arn = aws_lb.alb.arn
  port              = "443"
  protocol          = "HTTPS"
  ssl_policy        = "ELBSecurityPolicy-TLS13-1-2-2021-06"
  certificate_arn   = var.alb_certificate_arn

  default_action {
    type             = "forward"
    target_group_arn = var.target_group_arn
  }
}

resource "aws_lb_listener" "alb_http" {
  load_balancer_arn = aws_lb.alb.arn
  port              = "80"
  protocol          = "HTTP"

  default_action {
    type = "redirect"
    redirect {
      status_code = "HTTP_301"
      protocol    = "HTTPS"
      port        = "443"
    }
  }
}

resource "aws_wafv2_web_acl" "waf" {
  name        = "app-alb-waf"
  description = "WAF for ALB app-alb"
  scope       = "REGIONAL"
  default_action {
    allow {}
  }
  visibility_config {
    cloudwatch_metrics_enabled = true
    metric_name                = "app-alb-waf"
    sampled_requests_enabled   = true
  }
  rule {
    name     = "AWS-AWSManagedRulesCommonRuleSet"
    priority = 1
    override_action {
      none {}
    }
    statement {
      managed_rule_group_statement {
        name        = "AWSManagedRulesCommonRuleSet"
        vendor_name = "AWS"
      }
    }
    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "AWSManagedRulesCommonRuleSet"
      sampled_requests_enabled   = true
    }
  }
  tags = local.common_tags
}

resource "aws_wafv2_web_acl_association" "waf_assoc" {
  resource_arn = aws_lb.alb.arn
  web_acl_arn  = aws_wafv2_web_acl.waf.arn
}

resource "aws_lb_listener_rule" "alb_default_headers" {
  listener_arn = aws_lb_listener.alb_https.arn
  priority     = 100

  action {
    type             = "forward"
    target_group_arn = var.target_group_arn
  }

  condition {
    http_header {
      http_header_name = "X-Forwarded-Proto"
      values           = ["https"]
    }
  }
}