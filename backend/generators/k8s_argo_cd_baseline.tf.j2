// Generated by TerraformManager â€” Kubernetes Argo CD hardened install
{% if backend %}
terraform {
  backend "s3" {
    endpoint                    = "{{ backend.endpoint }}"
    bucket                      = "{{ backend.bucket }}"
    key                         = "{{ backend.key }}"
    region                      = "{{ backend.region }}"
    skip_credentials_validation = true
    skip_region_validation      = true
    force_path_style            = true
  }
}
{% endif %}

provider "kubernetes" {
  host                   = var.kube_host
  token                  = var.kube_token
  cluster_ca_certificate = base64decode(var.kube_ca)
}

provider "helm" {
  kubernetes {
    host                   = var.kube_host
    token                  = var.kube_token
    cluster_ca_certificate = base64decode(var.kube_ca)
  }
}

variable "kube_host" { description = "https://your-api-server:6443" }
variable "kube_token" { description = "Service account token" }
variable "kube_ca"    { description = "Base64-encoded cluster CA" }

locals {
  namespace_labels = {
    managed_by   = "TerraformManager"
    environment  = "{{ environment }}"
    team         = "{{ team_label }}"
    "pod-security.kubernetes.io/enforce"         = "restricted"
    "pod-security.kubernetes.io/enforce-version" = "latest"
    "pod-security.kubernetes.io/audit"           = "restricted"
    "pod-security.kubernetes.io/warn"            = "baseline"
  }
}

resource "kubernetes_namespace" "{{ namespace_resource_name }}" {
  metadata {
    name   = "{{ namespace_actual }}"
    labels = local.namespace_labels
  }
}

resource "kubernetes_network_policy" "{{ namespace_resource_name }}_baseline" {
  metadata {
    name      = "{{ namespace_actual }}-baseline"
    namespace = kubernetes_namespace.{{ namespace_resource_name }}.metadata[0].name
    labels = {
      managed_by = "TerraformManager"
    }
  }
  spec {
    pod_selector {}
    ingress {
      from {
        pod_selector {}
      }
{% for cidr in allowed_cidrs %}
      from {
        ip_block {
          cidr = "{{ cidr }}"
        }
      }
{% endfor %}
    }
    egress {
      to {
        namespace_selector {
          match_labels = {
            "kubernetes.io/metadata.name" = "kube-system"
          }
        }
      }
      ports {
        port     = 53
        protocol = "UDP"
      }
      ports {
        port     = 53
        protocol = "TCP"
      }
    }
{% if allowed_cidrs %}
    {% for cidr in allowed_cidrs %}
    egress {
      to {
        ip_block { cidr = "{{ cidr }}" }
      }
    }
    {% endfor %}
{% endif %}
    policy_types = ["Ingress", "Egress"]
  }
}

{% if set_resource_quota %}
resource "kubernetes_resource_quota" "{{ namespace_resource_name }}_quota" {
  metadata {
    name      = "{{ namespace_actual }}-quota"
    namespace = kubernetes_namespace.{{ namespace_resource_name }}.metadata[0].name
  }
  spec {
    hard = {
      "requests.cpu"    = "{{ quota_requests_cpu }}"
      "requests.memory" = "{{ quota_requests_memory }}"
      "limits.cpu"      = "{{ quota_limits_cpu }}"
      "limits.memory"   = "{{ quota_limits_memory }}"
      "pods"            = "{{ quota_pods }}"
    }
  }
}
{% endif %}

resource "helm_release" "{{ release_resource_name }}" {
  name       = "{{ release_name }}"
  repository = "{{ helm_repository }}"
  chart      = "argo-cd"
  version    = "{{ chart_version }}"
  namespace  = kubernetes_namespace.{{ namespace_resource_name }}.metadata[0].name
  create_namespace = false
  cleanup_on_fail  = true
  timeout          = 600

  values = [
    yamlencode({
      global = {
        addPrometheusAnnotations = false
        securityContext = {
          runAsNonRoot = true
          runAsUser    = 999
          fsGroup      = 999
        }
        networkPolicy = {
          create = true
        }
      }
      configs = {
        cm = {
          "accounts.admin.enabled" = "{{ "false" if disable_admin else "true" }}"
          "exec.enabled"           = "false"
          "server.rbac.log.enforce.enable" = "true"
          "url"                    = "{{ external_url }}"
        }
        params = {
          "server.insecure"            = "false"
          "server.disable.auth"        = "false"
          "applicationsetcontroller.enabled" = "{{ "true" if enable_appset else "false" }}"
          "controller.diff.server.side" = "false"
        }
      }
      controller = {
        replicas = {{ controller_replicas }}
        podSecurityContext = {
          runAsNonRoot = true
          runAsUser    = 999
          fsGroup      = 999
        }
        containerSecurityContext = {
          allowPrivilegeEscalation = false
          readOnlyRootFilesystem   = true
          capabilities = {
            drop = ["ALL"]
          }
        }
        metrics = { enabled = false }
      }
      server = {
        autoscaling = { enabled = false }
        service = {
          type = "ClusterIP"
        }
        podSecurityContext = {
          runAsNonRoot = true
          runAsUser    = 999
          fsGroup      = 999
        }
        containerSecurityContext = {
          allowPrivilegeEscalation = false
          readOnlyRootFilesystem   = true
          capabilities = {
            drop = ["ALL"]
          }
        }
{% if enable_ingress %}
        ingress = {
          enabled = true
{% if ingress_class %}
          ingressClassName = "{{ ingress_class }}"
{% endif %}
          hosts = [
            {
              host  = "{{ ingress_host }}"
              paths = [{ path = "/", pathType = "Prefix" }]
            }
          ]
{% if tls_secret_name %}
          tls = [
            {
              hosts      = ["{{ ingress_host }}"]
              secretName = "{{ tls_secret_name }}"
            }
          ]
{% endif %}
        }
{% else %}
        ingress = {
          enabled = false
        }
{% endif %}
      }
      repoServer = {
        podSecurityContext = {
          runAsNonRoot = true
          runAsUser    = 999
          fsGroup      = 999
        }
        containerSecurityContext = {
          allowPrivilegeEscalation = false
          readOnlyRootFilesystem   = true
          capabilities = {
            drop = ["ALL"]
          }
        }
        env = [
          {
            name  = "ARGOCD_GPG_ENABLED"
            value = "true"
          }
        ]
      }
      applicationSet = {
        enabled = {{ "true" if enable_appset else "false" }}
      }
      dex = {
        enabled = {{ "true" if enable_dex else "false" }}
      }
      redis = {
        metrics = {
          enabled = false
        }
      }
    })
  ]

  depends_on = [
    kubernetes_namespace.{{ namespace_resource_name }},
    kubernetes_network_policy.{{ namespace_resource_name }}_baseline{% if set_resource_quota %},
    kubernetes_resource_quota.{{ namespace_resource_name }}_quota{% endif %}
  ]
}

output "{{ release_resource_name }}_namespace" {
  description = "Namespace where Argo CD is installed"
  value       = kubernetes_namespace.{{ namespace_resource_name }}.metadata[0].name
}

output "{{ release_resource_name }}_server_service" {
  description = "Internal service name for Argo CD API server"
  value       = "argocd-server.${kubernetes_namespace.{{ namespace_resource_name }}.metadata[0].name}.svc.cluster.local"
}
