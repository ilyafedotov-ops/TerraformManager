from __future__ import annotations

import base64
from io import BytesIO
from typing import Any, Dict, List
import zipfile

from .models import BlueprintComponent, BlueprintRemoteStateAzure, BlueprintRemoteStateConfig, BlueprintRemoteStateS3, BlueprintRequest
from .registry import GeneratorDefinition, get_generator_definition


def _apply_environment_placeholders(value: Any, environment: str) -> Any:
    if isinstance(value, str):
        return value.replace("{env}", environment)
    if isinstance(value, list):
        return [_apply_environment_placeholders(item, environment) for item in value]
    if isinstance(value, dict):
        return {key: _apply_environment_placeholders(val, environment) for key, val in value.items()}
    return value


def _prepare_component_payload(
    definition: GeneratorDefinition,
    component: BlueprintComponent,
    environment: str,
) -> Dict[str, Any]:
    raw_payload = component.payload or {}
    hydrated = _apply_environment_placeholders(raw_payload, environment)

    # Auto-populate optional environment field if present and not provided
    if (
        "environment" in definition.model.model_fields
        and "environment" not in hydrated
    ):
        hydrated["environment"] = environment

    return hydrated


def _render_remote_state_block(remote_state: BlueprintRemoteStateConfig, environment: str) -> str:
    if isinstance(remote_state, BlueprintRemoteStateS3):
        settings = remote_state.resolve(environment)
        data = settings.model_dump()
        bucket = _apply_environment_placeholders(data["bucket"], environment)
        key = _apply_environment_placeholders(data["key"], environment)
        region = _apply_environment_placeholders(data["region"], environment)
        ddb = _apply_environment_placeholders(data["dynamodb_table"], environment)
        return (
            'terraform {\n'
            '  backend "s3" {\n'
            f'    bucket         = "{bucket}"\n'
            f'    key            = "{key}"\n'
            f'    region         = "{region}"\n'
            f'    dynamodb_table = "{ddb}"\n'
            "    encrypt        = true\n"
            "  }\n"
            "}\n"
        )
    if isinstance(remote_state, BlueprintRemoteStateAzure):
        settings = remote_state.resolve(environment)
        data = settings.model_dump()
        resource_group = _apply_environment_placeholders(data["resource_group"], environment)
        storage_account = _apply_environment_placeholders(data["storage_account"], environment)
        container = _apply_environment_placeholders(data["container"], environment)
        key = _apply_environment_placeholders(data["key"], environment)
        return (
            'terraform {\n'
            '  backend "azurerm" {\n'
            f'    resource_group_name  = "{resource_group}"\n'
            f'    storage_account_name = "{storage_account}"\n'
            f'    container_name       = "{container}"\n'
            f'    key                  = "{key}"\n'
            "  }\n"
            "}\n"
        )
    raise ValueError("Unsupported remote state configuration")


def _render_variables_stub(environment: str) -> str:
    return (
        f'# Variables for {environment}\n'
        '# Declare per-environment overrides here, e.g.:\n'
        '# variable "app_name" {\n'
        '#   type        = string\n'
        '#   description = "Application identifier"\n'
        '# }\n'
    )


def _render_readme(request: BlueprintRequest) -> str:
    lines = [
        f"# {request.name} Blueprint",
        "",
        "## Environments",
    ]
    lines.extend(f"- {env}" for env in request.environments)
    lines.append("")
    lines.append("## Components")
    for component in request.components:
        lines.append(f"- `{component.slug}`")
    if request.remote_state:
        backend_type = "S3" if isinstance(request.remote_state, BlueprintRemoteStateS3) else "Azure Storage"
        lines.append("")
        lines.append(f"Remote state: {backend_type}")
    lines.append("")
    lines.append("Generated by TerraformManager.")
    return "\n".join(lines) + "\n"


def render_blueprint_bundle(request: BlueprintRequest) -> Dict[str, Any]:
    files: List[Dict[str, str]] = []

    for environment in request.environments:
        env_dir = f"environments/{environment}"

        if request.remote_state:
            backend_content = _render_remote_state_block(request.remote_state, environment)
            files.append({"path": f"{env_dir}/backend.tf", "content": backend_content})

        if request.include_variables_stub:
            files.append({"path": f"{env_dir}/variables.tf", "content": _render_variables_stub(environment)})

        for component in request.components:
            definition = get_generator_definition(component.slug)
            payload = _prepare_component_payload(definition, component, environment)
            rendered = definition.render(payload)
            subdir = component.target_subdir.strip("/") if component.target_subdir else ""
            if subdir:
                path = f"{env_dir}/{subdir}/{rendered['filename']}"
            else:
                path = f"{env_dir}/{rendered['filename']}"
            files.append({"path": path, "content": rendered["content"]})

    if request.include_readme:
        files.append({"path": "README.md", "content": _render_readme(request)})

    archive_name = f"{request.name.lower().replace(' ', '_')}_blueprint.zip"
    buffer = BytesIO()
    with zipfile.ZipFile(buffer, "w", compression=zipfile.ZIP_DEFLATED) as zf:
        for item in files:
            zf.writestr(item["path"], item["content"])
    archive_bytes = buffer.getvalue()

    return {
        "archive_name": archive_name,
        "files": files,
        "archive_bytes": archive_bytes,
        "archive_base64": base64.b64encode(archive_bytes).decode("ascii"),
    }


__all__ = ["render_blueprint_bundle"]
